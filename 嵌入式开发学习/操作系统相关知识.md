# 操作系统基础知识

1、操作系统定义：操作系统是用以控制和管理计算机硬件和软件资源、合理地组织计算机的工作流程以及方便用户使用计算机的程序的集合。

-   1、操作系统统一控制和管理计算机系统所拥有的硬件和软件资源，使之可以得到更加有效合理的利用。
-   2、操作系统能合理地组织计算机系统的工作流程，增强系统的处理能力。
-   3、操作系统提供了用户与裸机之间的接口，使用户更方便地使用计算机。

2、操作系统的功能：操作系统的基本功能包括：

-   处理机管理；
-   存储管理；
-   设备管理；
-   信息管理（文件系统管理）
-   作业管理等

3、操作系统的根本目标：实现系统资源的最大吞吐率，使用户充分、有效的利用系统资源。

# μC/OS-II应用编程

1、μC/OS-II是一种专门为嵌入式设备设计的，基于优先级的可抢先式的硬实时EOS内核。

> 内核，是一个操作系统的核心。它负责管理系统的进程、内存、设备驱动程序、文件和网络系统，决定着系统的性能和稳定性。

2、μC/OS-II特点：

-   执行效率高
-   占用空间小
-   实时性能优良
-   可扩展性强

3、实时系统：实时系统指系统的计算正确性不仅取决于计算的逻辑正确性，还取决于产生结果的时间。如果未满足系统的时间约束，则认为系统失败。  
4、一个实时操作系统面对变化的负载时必须确定性地保证满足时间要求。请注意，必须要满足确定性，而不是要求速度足够快！  
5、硬实时：硬实时系统指系统要有确保的最坏情况下的服务时间，即对于事件的响应时间的截止期限是无论如何都必须得到满足。  
6、软实时：软实时系统就是那些从统计的角度来说，一个任务能够得到有确保的处理时间，到达系统的事件也能够在截止期限到来之前得到处理，但违反截止期限并不会带来致命的错误。  
7、μC/OS-II的内核功能：

-   任务调度
-   任务管理
-   时间管理
-   内存管理
-   任务间的通信和同步

8、任务的定义：任务是一个具有独立功能的无限循环的程序段的一次运行活动。任务(task)是最抽象的,是一个一般性的术语,指由软件完成的一个活动。一个任务既可以是一个进程,也可以是一个线程。简而言之,它指的是一系列共同达到某一目的的操作。例如,读取数据并将数据放入内存中。这个任务可以作为一个进程来实现,也可以作为一个线程（或作为一个中断任务）来实现。  
9、EOS任务的特性：

-   任务（task）通常为进程和线程的统称；
-   任务是EOS内核调度的基本单位

> 程序：程序(program)是一组指令的有序集合。  
> 进程：进程(process)常常被定义为程序的执行。可以把一个进程看成是一个独立的程序,在内存中有其完备的数据空间和代码空间。  
> 线程：线程(tread)则是某一进程中一路单独运行的程序。也就是说,线程存在于进程之中。一个进程由一个或多个线程构成,各线程共享相同的代码和全局数据,但各有其自己的堆栈。由于堆栈是每个线程一个,所以局部变量对每一线程来说是私有的。由于所有线程共享同样的代码和全局数据,它们比进程更紧密,比单独的进程间更趋向于相互作用,线程间的相互作用更容易些,因为它们本身就有某些供通信用的共享内存：进程的全局数据。

10、任务的内容：

-   代码：一段可执行的程序
-   数据：程序所需要的相关数据（变量、缓冲区等）
-   堆栈
-   程序执行的上下文环境

11、任务参数  
11.1 任务的优先级  
（1）任务对应工作内容在处理上的优先程度  
（2）优先级越高，表明任务越需要得到优先处理  
（3）任务的优先级分为静态优先级和动态优先级：

-   静态优先级：任务的优先级被确定后，在系统运行过程中将不再发生变化；
-   动态优先级：系统运行过程中，任务的优先级是可以动态变化的。

11.2 任务周期：周期任务所具有的参数，表示任务周期性执行的间隔时间  
11.3 任务的计算时间：任务在特定硬件环境下被完整执行所需要的时间，也被称为是任务的执行时间（execution time）。  
11.4 就绪时间：任务具备了在处理器上被执行所需要条件时的时间  
11.5 截止时间：任务需要在该时间到来之前被执行完成

-   绝对截止时间
-   相对截止时间
-   关键任务
-   强实时系统
-   弱实时系统

12、任务的状态与变迁  
任务拥有的**资源情况发生变化导致任务状态发生改变**。  
![在这里插入图片描述](image/%E3%80%8A%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E3%80%8B%27s%20Image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9nb25nc2lyLmJsb2cuY3Nkbi5uZXQ=,size_16,color_FFFFFF,t_70.png)  
**补充：**  
空闲任务定义：

-   当没有就绪任务时执行的任务
-   优先级总是最低的任务
-   空闲任务永远不能被应用软件删除
-   空闲任务由操作系统创建

**统计任务使用OSIdleCtr来确定应用程序软件实际消耗的CPU时间（百分比）**

13、任务管理：任务管理是通过对任务控制块（Task Control Block，TCB）的操作来实现的。  
14、任务控制块：任务控制块是包含任务相关信息的数据结构，包含了任务执行过程中所需要的所有信息

-   任务的名字
-   任务执行的起始地址
-   任务的优先级（优先级机制的EOS内核中）
-   任务的状态
-   任务的硬件上下文（堆栈和指针、PC和寄存器等）
-   任务的队列指针等内容

15、任务管理机制

-   任务管理用来对任务状态的直接控制和访问
-   内核的任务管理是通过系统调用来体现，主要包括任务创建、任务删除、任务挂起、任务唤醒、设置任务属性、改变任务优先级、获取任务信息等内容。

**补充：关于任务扩展：**  
![在这里插入图片描述](image/%E3%80%8A%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E3%80%8B%27s%20Image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9nb25nc2lyLmJsb2cuY3Nkbi5uZXQ=,size_16,color_FFFFFF,t_70-166487964678216.png)

> **任务扩展表用来存放实现任务扩展处理的例程，实时内核通过查找任务扩展表来获取扩展处理的入口函数。**  
> **通过创建任务扩展表，把任务扩展例程添加到系统中去；通过删除任务扩展表则可把任务扩展例程删除掉。**

16、任务调度  
1）任务队列：由任务控制块组成  
![在这里插入图片描述](image/%E3%80%8A%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E3%80%8B%27s%20Image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9nb25nc2lyLmJsb2cuY3Nkbi5uZXQ=,size_16,color_FFFFFF,t_70-166487964678217.png)  
单等待队列：  
![在这里插入图片描述](image/%E3%80%8A%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E3%80%8B%27s%20Image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9nb25nc2lyLmJsb2cuY3Nkbi5uZXQ=,size_16,color_FFFFFF,t_70-166487964678218.png)  
多等待队列：  
![在这里插入图片描述](image/%E3%80%8A%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E3%80%8B%27s%20Image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9nb25nc2lyLmJsb2cuY3Nkbi5uZXQ=,size_16,color_FFFFFF,t_70-166487964678219.png)  
2）任务调度-优先级位图算法：[优先级位图算法详解](https://gongsir.blog.csdn.net/article/details/103811432)  
3）任务切换时机：  
![在这里插入图片描述](image/%E3%80%8A%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E3%80%8B%27s%20Image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9nb25nc2lyLmJsb2cuY3Nkbi5uZXQ=,size_16,color_FFFFFF,t_70-166487964678320.png)  
4）任务切换基本步骤：

1.  保存任务的上下文环境
2.  更新当前运行任务的TCB内容，将其status改为就绪或者等待
3.  将任务控制块移到相应队列（就绪队列或者等待队列）
4.  选择另一个任务进行执行（调度）
5.  改变需投入运行任务的控制块内容，将其状态变为运行状态
6.  恢复需要投入运行任务的上下文环境

16、任务调度

-   调度用来确定多任务环境下任务执行的顺序和在获得CPU资源后能够执行的时间长度。
-   内核通过一个调度程序来实现调度功能

17、调度算法：在一个特定时刻用来确定将要运行的任务的一组规则  
18、离线调度和在线调度：根据获得调度信息的时机。  
![在这里插入图片描述](image/%E3%80%8A%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E3%80%8B%27s%20Image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9nb25nc2lyLmJsb2cuY3Nkbi5uZXQ=,size_16,color_FFFFFF,t_70-166487964678321.png)  
19、抢占式调度和非抢占式调度：任务在运行过程中能否被打断的处理情况。  
![在这里插入图片描述](image/%E3%80%8A%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E3%80%8B%27s%20Image/20200102204316362.png)  
20、内核的可抢占性  
![在这里插入图片描述](image/%E3%80%8A%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E3%80%8B%27s%20Image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9nb25nc2lyLmJsb2cuY3Nkbi5uZXQ=,size_16,color_FFFFFF,t_70-166487964678322.png)  
不可抢占内核：  
![在这里插入图片描述](image/%E3%80%8A%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E3%80%8B%27s%20Image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9nb25nc2lyLmJsb2cuY3Nkbi5uZXQ=,size_16,color_FFFFFF,t_70-166487964678323.png)  
可抢占内核：  
![在这里插入图片描述](image/%E3%80%8A%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E3%80%8B%27s%20Image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9nb25nc2lyLmJsb2cuY3Nkbi5uZXQ=,size_16,color_FFFFFF,t_70-166487964678324.png)  
21、静态和动态调度  
![在这里插入图片描述](image/%E3%80%8A%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E3%80%8B%27s%20Image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9nb25nc2lyLmJsb2cuY3Nkbi5uZXQ=,size_16,color_FFFFFF,t_70-166487964678325.png)  
22、**基于优先级的可抢占调度方式**：如果出现具有`更高优先级`的任务处于就绪状态时，当前任务将停止运行，把CPU的控制权交给具有更高优先级的任务，使更高优先级的任务得到执行。  
![在这里插入图片描述](image/%E3%80%8A%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E3%80%8B%27s%20Image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9nb25nc2lyLmJsb2cuY3Nkbi5uZXQ=,size_16,color_FFFFFF,t_70-166487964678326.png)  
23、**时间片轮转调度**：当有两个或多个就绪任务具有相同的优先级，且它们是就绪任务中优先级最高的任务时，任务调度程序按照这组任务就绪的先后次序调度第一个任务，让第一个任务运行一段时间，然后又调度第二个任务，让第二个任务又运行一段时间，依次类推，到该组最后一个任务也得以运行一段时间后，接下来又让第一个任务运行。任务运行的这段时间称为`时间片`  
![在这里插入图片描述](image/%E3%80%8A%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E3%80%8B%27s%20Image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9nb25nc2lyLmJsb2cuY3Nkbi5uZXQ=,size_16,color_FFFFFF,t_70-166487964678327.png)  
24、小结：

> 调度用来确定多任务环境下任务执行的`顺序`和在获得CPU资源后能够执行的`时间长度`。  
> 操作系统通过一个`调度程序`来实现调度功能。调度本身需要一定的系统开销，需要花费时间来计算下一个可被执行的任务。  
> 调度程序的设计需要优先考虑最重要的需求，然后在各种因素之间进行`折衷处理`。  
> 常用的任务调度算法有`基于优先级的可抢占调度`和`时间片轮转调度算法`。

25、优先级反转（Priority Inversion）：高优先级任务需要等待低优先级任务释放资源，而低优先级任务又正在等待中等优先级任务的现象。

> 优先级反转和“死锁”的区别？  
> 优先级反转是高优先级的任务在特定的时间内得不到响应（打破实时性）  
> “死锁”是（无外界干涉的情况下）永远的阻塞

26、`动态优先级`为EOS解决优先级反转问题提供了思路，解决优先级反转现象的常用协议为： `优先级继承协议`、`优先级天花板协议`。  
27、优先级继承协议基本思想：

-   当一个任务阻塞了一个或多个高优先级任务时，该任务将不使用其原来的优先级，而使用被该任务所阻塞的所有任务的最高优先级作为其执行临界区的优先级。
-   当该任务退出临界区时，又恢复到其最初的优先级。  
    ![在这里插入图片描述](image/%E3%80%8A%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E3%80%8B%27s%20Image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9nb25nc2lyLmJsb2cuY3Nkbi5uZXQ=,size_16,color_FFFFFF,t_70-166487964678328.png)

28、优先级继承协议特点：

1.  只有在高优先级任务与低优先级任务共享临界资源，且低优先级任务已经进入临界区后，高优先级任务才可能被低优先级任务所阻塞；
2.  高优先级任务被低优先级任务阻塞的最长时间可以确定；
3.  如果有m个信号量可能阻塞任务T，则任务T最多被阻塞m次。

29、优先级继承协议优缺点：  
![在这里插入图片描述](image/%E3%80%8A%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E3%80%8B%27s%20Image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9nb25nc2lyLmJsb2cuY3Nkbi5uZXQ=,size_16,color_FFFFFF,t_70-166487964678329.png)  
30、优先级继承协议——死锁：  
![在这里插入图片描述](image/%E3%80%8A%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E3%80%8B%27s%20Image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9nb25nc2lyLmJsb2cuY3Nkbi5uZXQ=,size_16,color_FFFFFF,t_70-166487964678330.png)  
假定在时刻t1，任务T2获得信号量S2，进入临界区。在时刻t3，任务T2又试图获得信号量S1，但一个高优先级任务T1在这个时候就绪，抢占任务T2并获得信号量S1，接下来任务T1又试图获得信号量S2。这样就出现了`死锁现象`。

31、优先级继承协议——阻塞链：  
![在这里插入图片描述](image/%E3%80%8A%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E3%80%8B%27s%20Image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9nb25nc2lyLmJsb2cuY3Nkbi5uZXQ=,size_16,color_FFFFFF,t_70-166487964678431.png)  
任务T3在S1控制的临界区中被T2抢占，然后T2进入S2控制的临界区。这个时候，任务T1被激活而获得CPU资源，发现信号量S1和S2都分别被低优先级任务T2和T3加锁，使得T1将被阻塞两个临界区，需要先等待任务T3释放信号量S1，然后等待任务T2释放信号量S2，这样就形成了关于任务T1的`阻塞链`。

32、优先级天花板协议  
![在这里插入图片描述](image/%E3%80%8A%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E3%80%8B%27s%20Image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9nb25nc2lyLmJsb2cuY3Nkbi5uZXQ=,size_16,color_FFFFFF,t_70-166487964678432.png)  
33、优先级天花板协议的主要处理内容：

1.  对于控制临界区的信号量，设置信号量的优先级天花板为可能申请该信号量的所有任务中具有最高优先级任务的优先级；
2.  如果任务成功获得信号量，任务的优先级将被抬升为信号量的优先级天花板；任务执行完临界区，释放信号量后，其优先级恢复到其最初的优先级；
3.  如果任务不能获得所申请的信号量，任务将被阻塞。

34、信号量分类：互斥信号量、二值信号量、计数信号量  
35、任务间的通信方式分类：  
![在这里插入图片描述](image/%E3%80%8A%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E3%80%8B%27s%20Image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9nb25nc2lyLmJsb2cuY3Nkbi5uZXQ=,size_16,color_FFFFFF,t_70-166487964678433.png)  
36、`系统调用`：是操作系统提供给用户程序调用的一组`特殊接口`。用户程序可以通过这组特殊接口来获得操作系统内核提供的服务。  
37、`用户编程接口`：遵循了在Unix世界中最流行的应用编程界面标准——POSIX标准，这套标准定义了一系列API。  
38、`系统命令`：系统命令相对编程接口更高了一层，它是内部引用API的可执行程序，如常用的系统命令ls、hostname等。  
39、`内核函数`其实它们和普通函数很像，只不过在内核实现，因此要满足一些内核编程的要求。  
40、关系：  
![在这里插入图片描述](image/%E3%80%8A%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E3%80%8B%27s%20Image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9nb25nc2lyLmJsb2cuY3Nkbi5uZXQ=,size_16,color_FFFFFF,t_70-166487964678434.png)

-   系统调用`并非直接和程序员或系统管理员打交道`，它仅仅`是一个通过软中断机制向内核提交请求`，获取`内核服务的接口`。
-   在实际使用中`程序员调用的多是用户编程接口——API`，而管理员使用的则多是系统命令。
-   `用户编程接口其实是函数定义`，说明了如何获得一个给定的服务，比如read()、abs()等。
-   `内核函数`其实它们和普通函数很像，只不过`在内核实现`，因此要满足一些内核编程的要求。
-   用户编程接口有可能和系统调用形式上一致
    -   比如read()接口就和read系统调用对应，但这种对应并非一一对应，往往会出现几种不同的API内部用到统一个系统调用，比如malloc()、free（）内部利用brk( )系统调用来扩大或缩小进程的堆；
    -   或一个API利用了好几个系统调用组合完成服务。更有些API甚至不需要任何系统调用，如计算整数绝对值的abs（）接口。