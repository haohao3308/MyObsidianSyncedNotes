实现串口烧写技术软件分为PC机内用于数据发送的顶层软件和目标机内的底层软件。顶层软件可实现用户程序的解析等；而底层软件可实现由串口发送的数据烧写至Flash。F2812DSP每次上电复位，先运行底层软件，判断是否需要重新烧写Flash。若需要，则将串口发送的目标代码烧写至F2812片内Flash指定扇区；否则将继续执行原有的用户目标代码。烧录过程主要包括以下三个核心模块：

* 上位机软件GUI，实现与DSP命令交换和升级代码的传输；

* DSP板子里的BootLoader程序，包含通信代码和flash API编程代码

* 用户升级的应用程序APPCODE




1 顶层软件

     顶层软件可实现用户程序的解析等工作。其用户程序为．oul文件，顶层软件主要完成．hex文件的解析，并将解析后的有用数据发送至目标DSP。.hex文件的组织格式严格，只要提取数据在内存中的存放地址和数据长度就可以按照要求将数据发送给目标DSP。如果用户程序很大而目标DSP的内存空间不足时，该过程还可以分段进行。顶层软件可以使用VC++或者LabVIEW等实现。

2 底层软件

      底层软件用于实现将串口发来的数据烧写至Flash．涉及到用户程序的正确定位和复位后的启动过程，是整个软件设计的重点。底层软件主要实现以下功能：
    
    (1)烧写程序搬移功能。由于F2812片上Flash不支持在其中一个扇区运行程序去擦除或烧写其他扇区，故完成接收数据和烧写Flash工作的这部分程序需搬移至片内RAM或片外RAM上运行
    
     (2)上电复位查询功能。上电复位后查询一个通用I／O端口的状态以确定是否需要烧写程序。这个通用I／O端口可由用户自行确定，但I／O端口占用后其特殊功能便不可用，上电复位后保证其确定状态，否则会不间断烧写程序或者不能正确跳转到用户应用程序。
    
      (3)接收PC机发送的数据并保存到目标DSP内存。这是在串口接收中断服务子程序中完成的，并确定用于数据保存的这部分内存未占用。
    
     (4)接收结束后将内存中的数据烧写至指定Flash扇区，这由Flash28lx_APl函数完库成。图1为底层应用软件流程图。

 



3 底层软件的定位

     电复位后，XMP／MC引脚为低电平．目标DSP处于计算机模式，CPU将从内部Boot Rom获得复位向量。复位向量指向BootRom并执行其内部的Bootloader程序，执行完毕后确定从内部Flash启动．程序指针跳转到Flash的Ox3F7FF6处．这个地址是同定的，因此底层软件程序必须烧写在以这个地址为起始地址的空间内，或者在0x3F7FF6烧写一条跳转指令，上电复位后通过跳转指令跳转到底层软件程序。

4 用户应用程序的定位

     用户应用程序从main函数开始，但DSP首先必须调用_c_int00函数建立C语言的运行环境，主要包括：建立初始化系统堆栈，把．cinit段中的数据表拷贝到.bss段。对全局和静态变量初始化等。_c_int00执行结束后调用main函数开始运行用户应用程序。因此_c_int00函数的首地址才是整个程序的入口点。底层软件程序执行结束后应该调用_c_int00函数，而不是main函数，可用跳转指令实现，参考程序如下：






Flash在线烧写操作就是将保存起来的DATA，烧写到二级加载程序搬移表所指定位置的Flash中。在线烧写的思想是，首先将保存起来的DATA加载到DSP的内部RAM或系统的外部RAM中，再通过在线烧写程序将加载的DATA写入到Flash中。DSP实验板Flash采用的是AM29LV160D，根据其数据手册分别建立擦除voidChipErase(void)和写入Byte Write(int offsent，short data)子函数。编写在线烧写程序如下：



在对Flash写操作前首先要进行其擦除，在擦除后要指定DATA存放首地址Saddr，要烧写到的Flash首地址FlashAddr，以及待烧写的数据长度Length。在有多个DATA段时，程序中要进行相应个数的DATA段烧写指定操作。

在线烧写程序设计完成后，编译将．out文件下载到DSP中，可以在擦除操作完成，开始烧写前设置断点，运行完Flash擦除操作后，将保存的DATA加载到程序中指定的位置，为了确保烧写程序的正常运行，不能将DATA加载到烧写程序占据的RAM空间。当所需要烧写的DATA全部加载完成后继续运行烧写程序，即可完成Flash的在线烧写。

https://icode.best/i/56574646372301

![在这里插入图片描述](image/%E3%80%8A%E4%B8%B2%E5%8F%A3%E7%83%A7%E5%BD%95%E8%BF%87%E7%A8%8B%E3%80%8B%27s%20Image/9f969a257afa4947a4e22411e3aaa679.png)我们以上图中的 STM32为例来进行分析和理解

**1,空间大小问题**

**Flash大小** 32kBytes 意思是 32*1024 = 32768 字节(Bytes)
**RAM大小** 8kBytes 意思是 8*1024 = 8192字节(Bytes)

**2,代码及变量存储问题**
我们以KEIL编译器 给我们提供的信息为例来进行分析和理解 如下图 整个程序被分为了 4部分
![在这里插入图片描述](image/%E3%80%8A%E4%B8%B2%E5%8F%A3%E7%83%A7%E5%BD%95%E8%BF%87%E7%A8%8B%E3%80%8B%27s%20Image/5e9e2be6a817415480604f2da7159ba9.png)
1,**代码:** 编译后的代码 会存储在 Flash 中. (这样掉电不会丢失)
2,**只读数据:** 只读数据(大多为常量) 存储在 Flash 中. (这样掉电不会丢失)
3, **已经赋值的变量:** 已经赋初值的变量 用户定义的初值也会存储在 Flash 中. (这样掉电不会丢失). 同时上电程序初始化运行的时候会把 此数据拿出来 放到RAM中

4, **没有赋值的变量:** 没有赋值的变量 会在上电程序运行的过程中 存在RAM中 (掉电丢失)

所以我们得到结论 Falsh 应该满足1+2+3
RAM 应该满足 2+3

**另外我们还需要注意 单片机本身底层的一些 处理逻辑也会占用一部分**
我们来看一下代码超过编译内存后的提示:
**英文提示**
![在这里插入图片描述](image/%E3%80%8A%E4%B8%B2%E5%8F%A3%E7%83%A7%E5%BD%95%E8%BF%87%E7%A8%8B%E3%80%8B%27s%20Image/e7b73372a8f84e5292505ea0e81b72b1.png)中文提示:
![在这里插入图片描述](image/%E3%80%8A%E4%B8%B2%E5%8F%A3%E7%83%A7%E5%BD%95%E8%BF%87%E7%A8%8B%E3%80%8B%27s%20Image/11e608a6607a42f198d86987c292f859.png)**提示中 我们可以得知 该芯片链接器生成的内容也会占用 Flash大小39字节**

同时 这39字节大小 已经在1 代码 这部分中被包含在里面了,所以我们计算的时候 就不需要在加上这39字节的数据了
